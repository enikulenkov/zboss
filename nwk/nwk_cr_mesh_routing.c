/***************************************************************************
*                      ZBOSS ZigBee Pro 2007 stack                         *
*                                                                          *
*          Copyright (c) 2012 DSR Corporation Denver CO, USA.              *
*                       http://www.dsr-wireless.com                        *
*                                                                          *
*                            All rights reserved.                          *
*          Copyright (c) 2011 ClarIDy Solutions, Inc., Taipei, Taiwan.     *
*                       http://www.claridy.com/                            *
*                                                                          *
*          Copyright (c) 2011 Uniband Electronic Corporation (UBEC),       *
*                             Hsinchu, Taiwan.                             *
*                       http://www.ubec.com.tw/                            *
*                                                                          *
*          Copyright (c) 2011 DSR Corporation Denver CO, USA.              *
*                       http://www.dsr-wireless.com                        *
*                                                                          *
*                            All rights reserved.                          *
*                                                                          *
*                                                                          *
* ZigBee Pro 2007 stack, also known as ZBOSS (R) ZB stack is available     *
* under either the terms of the Commercial License or the GNU General      *
* Public License version 2.0.  As a recipient of ZigBee Pro 2007 stack, you*
* may choose which license to receive this code under (except as noted in  *
* per-module LICENSE files).                                               *
*                                                                          *
* ZBOSS is a registered trademark of DSR Corporation AKA Data Storage      *
* Research LLC.                                                            *
*                                                                          *
* GNU General Public License Usage                                         *
* This file may be used under the terms of the GNU General Public License  *
* version 2.0 as published by the Free Software Foundation and appearing   *
* in the file LICENSE.GPL included in the packaging of this file.  Please  *
* review the following information to ensure the GNU General Public        *
* License version 2.0 requirements will be met:                            *
* http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.                   *
*                                                                          *
* Commercial Usage                                                         *
* Licensees holding valid ClarIDy/UBEC/DSR Commercial licenses may use     *
* this file in accordance with the ClarIDy/UBEC/DSR Commercial License     *
* Agreement provided with the Software or, alternatively, in accordance    *
* with the terms contained in a written agreement between you and          *
* ClarIDy/UBEC/DSR.                                                        *
*                                                                          *
****************************************************************************
PURPOSE: Network tree routing
*/

#include "zb_common.h"
#include "zb_scheduler.h"
#include "zb_mac.h"
#include "zb_nwk.h"
#include "zb_aps.h"
#include "nwk_internal.h"

#if defined ZB_NWK_MESH_ROUTING && defined ZB_ROUTER_ROLE
//#if 1

/*! \addtogroup ZB_NWK */
/*! @{ */

/* See 3.6.3 and doc/html/nwk/zigbee-mesh-routing-interactive-tutorial.html */

/** \par Network mesh routing

    The mesh routing is based on AODV which uses route requests, replies,
    and path costs to determine the best route for transmission. The
    sequence goes something like this:

    - A route request command frame is generated by the source node and
    broadcast to the network.
    - The route request propagates over the whole network and eventually
    reaches the destination node.
    - The destination node will send a route reply command frame to the node
    that sent the request.
    - The node that received the route reply will unicast it to the node
    that sent it the route request.
    - The path will be followed until it reaches the originating node.
    The originating node will add the route to its routing table.

    \par Route discovery table

    The route discovery table is used for implementing route discovery
    in Zigbee. When trying to discover a route, route request command
    frames are sent out. To understand the usage of the route discovery
    table, its probably best to understand the sequence of events for
    route discovery:

    - A route request command frame is broadcast from the source node.
    - Each node that receives the route request will create a route
    discovery table entry with the route request info.
    - Each node will then broadcast-relay the route request.
    - When the route request reaches the destination node, then the
    destination node will generate a unicast route reply to the node
    that sent it the route request.
    - The node receiving the route reply will then unicast the route
    reply to the node that sent it the route request previously by looking
    up the info in the discovery table. It will also add the path cost
    which is also stored in the discovery table.
    - The reply will be unicast until it reaches the source node.
    - After the specified route discovery time, the route discovery
    entry will expire and be removed from the table.
*/

#include "zb_bank_5.h"

/* Parse mac header. Mac header offset saved inside buffer header, to be able to
 * get mac hdr data. Get source address if mac hdr exists, otherwise get device
 * source address */
static void nwk_get_mac_source_addr(zb_buf_t *b, zb_uint16_t *s)
{
  if ( (b)->u.hdr.mac_hdr_offset )
  {
    zb_mac_mhr_t mac_hdr;
    zb_parse_mhr(&mac_hdr, ((b)->buf + (b)->u.hdr.mac_hdr_offset));
    *s = mac_hdr.src_addr.addr_short;
  }
  else
  {
    *s = ZB_NIB_NETWORK_ADDRESS();
  }
}

#if 0
/* This function called periodically to resend route requests */
void zb_nwk_mesh_expiry_rreq(zb_uint8_t param) ZB_CALLBACK;
#endif

/* This function called periodically to find expired discovery table entries */
void zb_nwk_mesh_expiry_route_disc(zb_uint8_t param) ZB_CALLBACK;
/* This function called periodically to find expired pending elements */
void zb_nwk_mesh_expiry_pending(zb_uint8_t param) ZB_CALLBACK;

/* Incoming route request handling */
void zb_nwk_mesh_rreq_handler(zb_buf_t *buf, zb_nwk_hdr_t *nwk_hdr, zb_nwk_cmd_rreq_t *nwk_cmd_rreq) ZB_SDCC_REENTRANT;

void zb_nwk_mesh_routing_init() ZB_SDCC_REENTRANT
{
  TRACE_MSG(TRACE_NWK1, ">> mesh_r_init", (FMT__0));

  /* Check for expired route discovery entries */
  TRACE_MSG(TRACE_NWK1, "schd r disc expiry f %d", (FMT__D,
           ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_route_disc, 0, ZB_NWK_EXPIRY_ROUTE_DISCOVERY)));

  /* Check for expired pending entries */
  TRACE_MSG(TRACE_NWK1, "schd pend expiry f %d", (FMT__D,
            ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_pending, 0, ZB_NWK_EXPIRY_PENDING)));

  TRACE_MSG(TRACE_NWK1, "<< mesh_r_init", (FMT__0));
}

/*
 * Generate and send a route request command frame.
 * Add route request entry into the rreq list to be able to track this request.
*/
static zb_ret_t zb_nwk_mesh_send_rreq(zb_buf_t *cbuf, zb_nwk_cmd_rreq_t *nwk_cmd_rreq, zb_uint16_t src_addr, zb_uint8_t seq_num, zb_uint8_t path_cost, zb_uint8_t radius) ZB_SDCC_REENTRANT
{
  zb_ret_t ret = RET_OK;

  TRACE_MSG(TRACE_NWK1, ">> send_rreq cbuf %p rreq %p s_addr %d path_cost %hd radius %hd", (FMT__P_P_D_H_H,
                         cbuf, nwk_cmd_rreq, src_addr, path_cost, radius));

#if 0
  /* check we have room in rreq table */
  if ( ZG->nwk.nib.rreq_cnt < ZB_NWK_RREQ_TABLE_SIZE )
#endif
  {
    zb_nwk_hdr_t *nwhdr;
    zb_nwk_cmd_rreq_t *rreq_cmd;
#if 0
    zb_nwk_rreq_t *rreq;
#endif
    zb_bool_t secure = ZB_FALSE;

#ifdef ZB_SECURITY
    secure = (ZG->aps.authenticated && ZG->nwk.nib.secure_all_frames
             && ZG->nwk.nib.security_level);
#endif

    nwhdr = nwk_alloc_and_fill_hdr(cbuf,
                                   ZB_NWK_BROADCAST_ROUTER_COORDINATOR, NULL, NULL, ZB_FALSE, secure, ZB_TRUE);
    rreq_cmd = (zb_nwk_cmd_rreq_t *)nwk_alloc_and_fill_cmd(cbuf, ZB_NWK_CMD_ROUTE_REQUEST, sizeof(zb_nwk_cmd_rreq_t));
    rreq_cmd->opt = 0;
    rreq_cmd->rreq_id = nwk_cmd_rreq->rreq_id;
    rreq_cmd->dest_addr = nwk_cmd_rreq->dest_addr;
    ZB_NWK_ADDR_TO_LE16(rreq_cmd->dest_addr);
    rreq_cmd->path_cost = path_cost;
    nwhdr->radius = radius;
    nwhdr->src_addr = src_addr;

    /* Not sure it is right, but let's assign original seq_num. Else request
     * can be dropped as a dup at receiver's side. */
    if (src_addr != ZB_NIB_NETWORK_ADDRESS())
    {
      nwhdr->seq_num = seq_num;
    }

#if 0
    /* Save info to retransmit request ZB_MWK_RREQ_RETRIES times */
    NWK_ROUTING_ARRAY_GET_ENT(ZG->nwk.nib.rreq, rreq, ZG->nwk.nib.rreq_cnt);
    ZB_ASSERT(rreq);
    if ( rreq )
    {
      rreq->originator = src_addr;
      rreq->radius = radius;
      rreq->retries = 1;
      memcpy(&rreq->cmd, rreq_cmd, sizeof(rreq->cmd));

      /* schedule resend function */
      if ( ZG->nwk.nib.rreq_cnt == 1 )
      {
        ZB_SCHEDULE_ALARM_CANCEL(zb_nwk_mesh_expiry_rreq, ZB_ALARM_ANY_PARAM);
        ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_rreq, -1, ZB_NWK_RREQ_RETRY_INTERVAL);
      }
    }
#endif

    /* transmit route request packet */
    ZB_SET_BUF_PARAM(cbuf, ZB_NWK_INTERNAL_NSDU_HANDLE, zb_uint8_t);
    ZB_SCHEDULE_CALLBACK(zb_nwk_forward, ZB_REF_FROM_BUF(cbuf));
  }
#if 0
  else
  {
    zb_free_buf(cbuf);
    TRACE_MSG(TRACE_NWK1, "rreq buffer is full", (FMT__0));
    ret = RET_NO_MEMORY;
  }
#endif

  TRACE_MSG(TRACE_NWK1, "<< send_rreq %d", (FMT__D, ret));
  return ret;
}

/*
 * Generate and send a route reply command frame.
*/
static zb_ret_t zb_nwk_mesh_send_rrep(zb_buf_t *cbuf, zb_uint8_t rreq_id, zb_uint16_t originator, zb_uint16_t responder, zb_uint8_t path_cost, zb_uint16_t sender_addr) ZB_SDCC_REENTRANT
{
  zb_ret_t ret = RET_OK;
  zb_nwk_hdr_t *nwhdr;
  zb_nwk_cmd_rrep_t *rrep;
  zb_uint8_t secure = 0;
#ifdef ZB_SECURITY
  secure = (ZG->aps.authenticated && ZG->nwk.nib.secure_all_frames
            && ZG->nwk.nib.security_level);
#endif
  TRACE_MSG(TRACE_NWK1, ">> send_rrep cbuf %p rreq_id %d orig %d resp %d p_cost %hd s_addr %d", (FMT__P_D_D_D_H_D,
                         cbuf, rreq_id, originator, responder, path_cost, sender_addr));
  nwhdr = nwk_alloc_and_fill_hdr(cbuf, sender_addr, NULL, NULL, ZB_FALSE, secure, ZB_TRUE);
  rrep = (zb_nwk_cmd_rrep_t *)nwk_alloc_and_fill_cmd(cbuf, ZB_NWK_CMD_ROUTE_REPLY, sizeof(zb_nwk_cmd_rrep_t));
  rrep->opt = 0;
  rrep->rreq_id = rreq_id;
  rrep->originator = originator;
  rrep->responder= responder;
  rrep->path_cost = path_cost;
  nwhdr->radius = (zb_uint8_t)(ZB_NIB_MAX_DEPTH() << 1);
  ZB_NWK_ADDR_TO_LE16(rrep->originator);
  ZB_NWK_ADDR_TO_LE16(rrep->responder);

  ZB_SET_BUF_PARAM(cbuf, ZB_NWK_INTERNAL_NSDU_HANDLE, zb_uint8_t);
  ZB_SCHEDULE_CALLBACK(zb_nwk_forward, ZB_REF_FROM_BUF(cbuf));

  TRACE_MSG(TRACE_NWK1, "<< snd_rrep %d", (FMT__D, ret));
  return ret;
}

/* This function is called when we got new buffer to initiate route discovery */
void zb_nwk_mesh_initiate_route_discovery(zb_uint8_t param) ZB_CALLBACK
{
  zb_nwk_pend_t *ent;
  zb_buf_t *cbuf = (zb_buf_t *)ZB_BUF_FROM_REF(param);

  TRACE_MSG(TRACE_NWK1, ">> initiate_route_discovery %hd", (FMT__H, param));

  NWK_ARRAY_FIND_ENT(ZG->nwk.nib.pending_table, ent, ent->waiting_buf);
  if ( ent )
  {
    zb_nwk_hdr_t *nwhdr = (zb_nwk_hdr_t *)ZB_BUF_BEGIN(ent->buf);

    zb_nwk_mesh_route_discovery(cbuf, nwhdr->dst_addr, 0);
    ent->waiting_buf = 0;
  }
  else
  {
    zb_free_buf(cbuf);
    TRACE_MSG(TRACE_NWK1, "perepil", (FMT__0));
    ZB_ASSERT(0);
  }

  TRACE_MSG(TRACE_NWK1, "<< initiate_route_discovery", (FMT__0));
}

/*
 * Sets up new route discovery operation.
 * Call rreq_handler to do a real discovery.
 */
void zb_nwk_mesh_route_discovery(zb_buf_t *cbuf, zb_uint16_t dest_addr, zb_uint8_t radius) ZB_SDCC_REENTRANT
{
  zb_nwk_hdr_t *nwk_hdr;
  zb_nwk_cmd_rreq_t *nwk_cmd_rreq;

  TRACE_MSG(TRACE_NWK1, ">> route_discovery cbuf %p dest_addr %d radius %hd", (FMT__P_D_H, cbuf, dest_addr, radius));

  if ( cbuf )
  {
    /* alloc space for nwk header and rreq cmd */
    ZB_BUF_INITIAL_ALLOC(cbuf, ZB_NWK_SHORT_HDR_SIZE(0), nwk_hdr);
    ZB_BUF_ALLOC_RIGHT(cbuf, sizeof(*nwk_cmd_rreq), nwk_cmd_rreq);
    ZB_ASSERT(nwk_hdr && nwk_cmd_rreq);

    /* fill meaningful hdr and command parameters for rrreq handler */
    nwk_cmd_rreq->opt = 0;
    nwk_cmd_rreq->rreq_id = ZB_NWK_GET_RREQ_ID();
    nwk_cmd_rreq->dest_addr = dest_addr;
    nwk_cmd_rreq->path_cost = 0;
    /* default radius = 2 * max depth */
    nwk_hdr->radius = radius ? radius : (zb_uint8_t)(ZG->nwk.nib.max_depth << 1);
    nwk_hdr->src_addr = ZB_NIB_NETWORK_ADDRESS();

    zb_nwk_mesh_rreq_handler(cbuf, nwk_hdr, nwk_cmd_rreq);
  }
  else
  {
    ZB_GET_OUT_BUF_DELAYED(zb_nwk_mesh_initiate_route_discovery);
  }

  TRACE_MSG(TRACE_NWK1, "<< route_discovery", (FMT__0));
}


/*
  Process an incoming route request and decide if it needs to be forwarded
  or a route reply needs to be generated. This function will check the
  discovery table to see if we received the same route request previously.
  If we did, then it will compare the path cost to see if the incoming route
  request has a more efficient path. If so, then it will replace the discovery
  entry info with the info from this route request.

  If its a new route request, then it will create a route discovery entry and a
  routing table entry. It will then check to see if its the destination. If so, then
  a route reply will be sent. Otherwise, it will relay the route request via
  broadcast.
*/
void zb_nwk_mesh_rreq_handler(zb_buf_t *buf, zb_nwk_hdr_t *nwk_hdr, zb_nwk_cmd_rreq_t *nwk_cmd_rreq) ZB_SDCC_REENTRANT
{
  zb_uint8_t ret = RET_OK;
  zb_uint8_t path_cost = 0;
  zb_nwk_route_discovery_t *disc_ent = NULL;
  zb_nwk_routing_t *routing_ent = NULL;

  TRACE_MSG(TRACE_NWK1, ">> rreq_handler buf %p hdr %p cmd %p", (FMT__P_P_P, buf, nwk_hdr, nwk_cmd_rreq));

  /* calc path cost */
  NWK_CALC_PATH_COST(nwk_hdr->src_addr, path_cost);
  TRACE_MSG(TRACE_NWK1, "path_cost %hd", (FMT__H, path_cost));
  path_cost += nwk_cmd_rreq->path_cost;
  TRACE_MSG(TRACE_NWK1, "total path_cost %hd", (FMT__H, path_cost));

  /* search in routing table */
  TRACE_MSG(TRACE_NWK1, "dst_addr %d", (FMT__D, nwk_cmd_rreq->dest_addr));
  NWK_ARRAY_FIND_ENT( ZG->nwk.nib.routing_table, routing_ent, (routing_ent->dest_addr == nwk_cmd_rreq->dest_addr) );
  if ( routing_ent )
  {
    TRACE_MSG(TRACE_NWK1, "r ent fnd, state %d", (FMT__D, routing_ent->status));
    if ( (routing_ent->status != ZB_NWK_ROUTE_STATE_ACTIVE)
         && (routing_ent->status != ZB_NWK_ROUTE_STATE_VALIDATION_UNDERWAY) )
    {
      routing_ent->status = ZB_NWK_ROUTE_STATE_DISCOVERY_UNDERWAY;
      TRACE_MSG(TRACE_NWK1, "change r ent state to dsc uway", (FMT__0));
    }
  }
  else
  {
    TRACE_MSG(TRACE_NWK1, "no routing enttry found, add new", (FMT__0));
    /* add new routing entry */
    NWK_ARRAY_GET_ENT(ZG->nwk.nib.routing_table, routing_ent, ZG->nwk.nib.routing_table_cnt);
    if ( routing_ent )
    {
      routing_ent->dest_addr = nwk_cmd_rreq->dest_addr;
      routing_ent->status = ZB_NWK_ROUTE_STATE_DISCOVERY_UNDERWAY;
      TRACE_MSG(TRACE_NWK1, "new routing ent : dest_addr %d status %hd", (FMT__D_H,
                routing_ent->dest_addr, routing_ent->status));
    }
    else
    {
      ret = RET_NO_MEMORY;
      TRACE_MSG(TRACE_ERROR, "no room for r ent, skip rreq", (FMT__0));
      goto done;
    }
  }

  /* search thought discovery table */
  TRACE_MSG(TRACE_NWK1, "rreq_id %hd src_addr %d", (FMT__H_D, nwk_cmd_rreq->rreq_id, nwk_hdr->src_addr));
  NWK_ARRAY_FIND_ENT( ZG->nwk.nib.route_disc_table, disc_ent,
                      (disc_ent->request_id == nwk_cmd_rreq->rreq_id) && (disc_ent->source_addr == nwk_hdr->src_addr) );
  if ( disc_ent )
  {
    TRACE_MSG(TRACE_NWK1, "dsc entry found, path_cost %hd forward_cost %hd", (FMT__H_H, path_cost, disc_ent->forward_cost));
    /* check path cost and update route disc entry */
    if ( path_cost < disc_ent->forward_cost )
    {
      zb_uint16_t src_addr;
      nwk_get_mac_source_addr(buf, &src_addr);

      TRACE_MSG(TRACE_NWK1, "new forward cost %hd node %d old %d", (FMT__H_D_D, path_cost, src_addr, disc_ent->sender_addr));
      /* replace route with better one */
      disc_ent->sender_addr = src_addr;
      disc_ent->forward_cost = path_cost;
    }
    else
    {
      /* this is normal case, do not change ret code */
      TRACE_MSG(TRACE_NWK1, "we have better path, skip rreq", (FMT__0));
      goto done;
    }
  }
  else
  {
    TRACE_MSG(TRACE_NWK1, "no disc ent, try to add new", (FMT__0));
    /* add new discovery entry */
    NWK_ARRAY_GET_ENT(ZG->nwk.nib.route_disc_table, disc_ent, ZG->nwk.nib.route_disc_table_cnt);
    if ( disc_ent )
    {
      zb_uint16_t src_addr;
      nwk_get_mac_source_addr(buf, &src_addr);

      disc_ent->request_id       = nwk_cmd_rreq->rreq_id;
      disc_ent->source_addr      = nwk_hdr->src_addr;
      disc_ent->sender_addr      = src_addr;
      disc_ent->dest_addr        = nwk_cmd_rreq->dest_addr;
      disc_ent->forward_cost     = path_cost;
      disc_ent->residual_cost    = 0xff;
      disc_ent->expiration_time  = ZB_NWK_ROUTE_DISCOVERY_EXPIRY;
      TRACE_MSG(TRACE_NWK1, "disc ent added: request_id %hd src_addr %d sndr_addr %d d_addr %d fwd_cost %hd res_cost %hd exp_time %d", (FMT__H_D_D_D_H_H_D,
                disc_ent->request_id, disc_ent->source_addr, disc_ent->sender_addr, disc_ent->dest_addr,
                disc_ent->forward_cost, disc_ent->residual_cost, disc_ent->expiration_time));
    }
    else
    {
      ret = RET_NO_MEMORY;
      TRACE_MSG(TRACE_ERROR, "no room f/disc ent, skip rreq", (FMT__0));
      goto done;
    }
  }

  /* check if this rreq is for us or our neighbour, send route reply in this
   * case, forward route request otherwise */
  {
    zb_neighbor_tbl_ent_t *nbt;

    if ( nwk_cmd_rreq->dest_addr == ZB_NIB_NETWORK_ADDRESS()
         || zb_nwk_neighbor_get_by_short(nwk_cmd_rreq->dest_addr, &nbt) == RET_OK )
    {
      zb_uint16_t src_addr;
      nwk_get_mac_source_addr(buf, &src_addr);

      TRACE_MSG(TRACE_ERROR, "this rreq f/us or neighbor, snd rrep", (FMT__0));
      zb_nwk_mesh_send_rrep(buf, nwk_cmd_rreq->rreq_id, nwk_hdr->src_addr, nwk_cmd_rreq->dest_addr, path_cost, src_addr);
      /* zb_nwk_mesh_send_rrep is now responsible for buffer */
      buf = NULL;
    }
    else
    {
      /* Buffer will be modified inside zb_nwk_mesh_send_rreq, save data we
       * need */
      zb_nwk_cmd_rreq_t nwk_cmd_rreq_save;
      ZB_MEMCPY(&nwk_cmd_rreq_save, nwk_cmd_rreq, sizeof(nwk_cmd_rreq_save));

      TRACE_MSG(TRACE_ERROR, "don't know rreq dest, prop it", (FMT__0));
      zb_nwk_mesh_send_rreq(buf, &nwk_cmd_rreq_save, nwk_hdr->src_addr, nwk_hdr->seq_num, path_cost, nwk_hdr->radius);
      /* zb_nwk_mesh_send_rreq is now responsible for buffer */
      buf = NULL;
    }
  }

  done:
  if ( ret != RET_OK )
  {
    TRACE_MSG(TRACE_NWK1, "error %d above, rm disc and r ent if", (FMT__D, ret));
    if ( disc_ent )
    {
      NWK_ARRAY_PUT_ENT(ZG->nwk.nib.route_disc_table, disc_ent, ZG->nwk.nib.route_disc_table_cnt);
    }
    if ( routing_ent )
    {
      NWK_ARRAY_PUT_ENT(ZG->nwk.nib.routing_table, routing_ent, ZG->nwk.nib.routing_table_cnt);
    }

    /* if this request was initiated by APS, confirm that route discovery failed */
    if ( ZG->nwk.nib.aps_rreq_addr
         && ZG->nwk.nib.aps_rreq_addr == nwk_cmd_rreq->dest_addr )
    {
      NWK_ROUTE_DISCOVERY_CONFIRM(buf, ZB_NWK_STATUS_ROUTE_ERROR, ZB_NWK_COMMAND_STATUS_NO_ROUTE_AVAILABLE);
      /* prevent buffer from being free */
      buf = NULL;
    }
  }

  if ( buf )
  {
    TRACE_MSG(TRACE_NWK1, "free buf %p", (FMT__P, buf));
    zb_free_buf(buf);
  }
  TRACE_MSG(TRACE_NWK1, "<< rreq_handler", (FMT__0));
}


/*
 * Process an incoming route reply.
 * First we need to make sure that we have a discovery table and routing table
 * entries for this route reply. If not or if path cost is greater than what we
 * have, then discard route reply.
 * If the route reply is for us, then end the route discovery process and send
 * out any frames that are buffered in the pending list. Otherwise, forward the
 * route reply to the sender of the route request as recorded in the discover
 * table entry.
 */
void zb_nwk_mesh_rrep_handler(zb_buf_t *buf, zb_nwk_hdr_t *nwk_hdr, zb_nwk_cmd_rrep_t *nwk_cmd_rrep) ZB_SDCC_REENTRANT
{
  zb_uint8_t path_cost;
  zb_nwk_route_discovery_t *disc_ent;
  zb_nwk_routing_t *routing_ent;
  zb_uint16_t src_addr;

  TRACE_MSG(TRACE_NWK1, ">> rrep_handler buf %p nwk_hdr %p nwk_cmd_rrep %p", (FMT__P_P_P, buf, nwk_hdr, nwk_cmd_rrep));

  /* parse mac header to get source address */
  nwk_get_mac_source_addr(buf, &src_addr);

  /* find proper discovery and routing table entries, calculate path cost */
  TRACE_MSG(TRACE_NWK1, "rrep cmd: rreq_id %hd orig %d resp %d", (FMT__H_D_D,
            nwk_cmd_rrep->rreq_id, nwk_cmd_rrep->originator, nwk_cmd_rrep->responder));

  /* clac path cost */
  NWK_CALC_PATH_COST(nwk_hdr->src_addr, path_cost);
  TRACE_MSG(TRACE_NWK1, "path_cost %hd", (FMT__H, path_cost));
  path_cost += nwk_cmd_rrep->path_cost;
  TRACE_MSG(TRACE_NWK1, "total path_cost %hd", (FMT__H, path_cost));
  ZB_NWK_ADDR_TO_LE16(nwk_cmd_rrep->responder);
  ZB_NWK_ADDR_TO_LE16(nwk_cmd_rrep->originator);
  NWK_ARRAY_FIND_ENT( ZG->nwk.nib.route_disc_table, disc_ent,
                      (disc_ent->request_id == nwk_cmd_rrep->rreq_id) && (disc_ent->source_addr == nwk_cmd_rrep->originator) );
  NWK_ARRAY_FIND_ENT( ZG->nwk.nib.routing_table, routing_ent,
                      (routing_ent->dest_addr == nwk_cmd_rrep->responder) );
  TRACE_MSG(TRACE_NWK1, "p_cost %d disc_ent %p r_ent %p residual_cost %hd", (FMT__D_P_P_H,\
            path_cost, disc_ent, routing_ent, disc_ent ? disc_ent->residual_cost : 0));

  /* check response is meaningful for us */
  if ( !disc_ent
       || !routing_ent
       || path_cost > disc_ent->residual_cost )
  {
    TRACE_MSG(TRACE_NWK1, "drop rresp, no purpose ent fnd or path too long", (FMT__0));
    if ( !disc_ent || !routing_ent )
    {
      TRACE_MSG(TRACE_NWK1, "one of disc or r ent is absent, free other", (FMT__0));
      if ( disc_ent )
      {
        NWK_ARRAY_PUT_ENT(ZG->nwk.nib.route_disc_table, disc_ent, ZG->nwk.nib.route_disc_table_cnt);
      }
      if ( routing_ent )
      {
        NWK_ARRAY_PUT_ENT(ZG->nwk.nib.routing_table, routing_ent, ZG->nwk.nib.routing_table_cnt);
      }
    }
    goto done;
  }

  /* update route and discovery entries */
  disc_ent->residual_cost    = path_cost;
  disc_ent->expiration_time  = ZB_NWK_ROUTE_DISCOVERY_EXPIRY;
  routing_ent->next_hop_addr = src_addr;
  routing_ent->status = (routing_ent->status == ZB_NWK_ROUTE_STATE_DISCOVERY_UNDERWAY) ? ZB_NWK_ROUTE_STATE_VALIDATION_UNDERWAY : routing_ent->status;

  /* check if rrep is for us */
  if ( nwk_cmd_rrep->originator == ZB_NIB_NETWORK_ADDRESS() )
  {
    zb_ushort_t i;
    TRACE_MSG(TRACE_NWK1, "got rrepl for our rreq, snd wait pckts", (FMT__0));

    /* Route discovery is complete. Now we have a new route. Go throught pending
     * queue to find packet to be forwarded */
    for(i = 0; i < ZB_NWK_PENDING_TABLE_SIZE; i++)
    {
      if ( ZG->nwk.nib.pending_table[i].used
           && ZG->nwk.nib.pending_table[i].dest_addr == routing_ent->dest_addr )
      {
        TRACE_MSG(TRACE_NWK1, "fnd pkt to %d addr, send it", (FMT__D, routing_ent->dest_addr));
        ZB_SET_BUF_PARAM(ZG->nwk.nib.pending_table[i].buf, ZG->nwk.nib.pending_table[i].handle, zb_uint8_t);
        ZB_SCHEDULE_CALLBACK(zb_nwk_forward, ZB_REF_FROM_BUF(ZG->nwk.nib.pending_table[i].buf));
        NWK_ARRAY_PUT_ENT(ZG->nwk.nib.pending_table, &ZG->nwk.nib.pending_table[i], ZG->nwk.nib.pending_table_cnt);
      }
    }

    /* if the request was initiated by APS, confirm that route discovery failed */
    TRACE_MSG(TRACE_NWK1, "aps_rreq_addr %d  dst_addr %d", (FMT__D_D, ZG->nwk.nib.aps_rreq_addr, routing_ent->dest_addr));
    if ( ZG->nwk.nib.aps_rreq_addr == routing_ent->dest_addr )
    {
      NWK_ROUTE_DISCOVERY_CONFIRM(buf, ZB_NWK_STATUS_SUCCESS, 0xff);
      ZG->nwk.nib.aps_rreq_addr = -1;
    }
  }
  else
  {
    /* forward */
    TRACE_MSG(TRACE_NWK1, "frwd rrep to the %d address", (FMT__D, disc_ent->sender_addr));
    zb_nwk_mesh_send_rrep(buf, nwk_cmd_rrep->rreq_id, nwk_cmd_rrep->originator, nwk_cmd_rrep->responder, path_cost, disc_ent->sender_addr);
    /* zb_nwk_mesh_send_rrep is now responsible for buf */
    buf = NULL;
  }

  done:
  if ( buf )
  {
    TRACE_MSG(TRACE_NWK1, "free buf %p", (FMT__P, buf));
    zb_free_buf(buf);
  }
  TRACE_MSG(TRACE_NWK1, "<< rrep_handler", (FMT__0));
}

#if 0
/* This function resend route request */
static void zb_nwk_mesh_resend_rreq(zb_buf_t *cbuf, zb_nwk_rreq_t *rreq)
{
  zb_nwk_hdr_t *nwhdr;
  zb_nwk_cmd_rreq_t *rreq_cmd;
  int total;

  TRACE_MSG(TRACE_NWK1, ">> resend_rreq cbuf %p rreq %p", (FMT__P_P, cbuf, rreq));

  rreq->retries++;

  /* fill nwk header */
  ZB_BUF_INITIAL_ALLOC(cbuf, ZB_NWK_SHORT_HDR_SIZE(0), nwhdr);
  ZB_BZERO2(nwhdr->frame_control);
  ZB_NWK_FRAMECTL_SET_FRAME_TYPE_N_PROTO_VER(nwhdr->frame_control, ZB_NWK_FRAME_TYPE_COMMAND, ZB_PROTOCOL_VERSION);
  /*ZB_NWK_FRAMECTL_SET_DISCOVER_ROUTE(nwhdr->frame_control, 0); implied*/

  nwhdr->src_addr = rreq->originator;
  nwhdr->dst_addr = ZB_NWK_BROADCAST_ROUTER_COORDINATOR;
  nwhdr->radius   = rreq->radius;
  nwhdr->seq_num  = ZB_NIB_SEQUENCE_NUMBER();
  ZB_NIB_SEQUENCE_NUMBER_INC();

  /* fill route request cmd&payload */
  ZB_NWK_ALLOC_COMMAND_GET_PAYLOAD_PTR(cbuf, ZB_NWK_CMD_ROUTE_REQUEST, zb_nwk_cmd_rreq_t, rreq_cmd);
  memcpy(rreq_cmd, &rreq->cmd ,sizeof(*rreq_cmd));

  /* transmit route request packet */
  ZB_SET_BUF_PARAM(cbuf, ZB_NWK_INTERNAL_NSDU_HANDLE, zb_uint8_t);
  ZB_SCHEDULE_CALLBACK(zb_nwk_forward, ZB_REF_FROM_BUF(cbuf));

  total = ( rreq->originator == ZB_NIB_NETWORK_ADDRESS() ) ?  ZB_MWK_INITIAL_RREQ_RETRIES : ZB_MWK_RREQ_RETRIES;
  TRACE_MSG(TRACE_NWK1, "sent %d times of %d total", (FMT__D_D, rreq->retries, total + 1));
  if ( rreq->retries > total )
  {
    NWK_ROUTING_ARRAY_PUT_ENT(ZG->nwk.nib.rreq, rreq, ZG->nwk.nib.rreq_cnt);
  }

  TRACE_MSG(TRACE_NWK1, "<< mesh_resend_rreq", (FMT__0));
}

/* This function called periodically to find expired route requests */
void zb_nwk_mesh_expiry_rreq(zb_uint8_t param) ZB_CALLBACK
{
  TRACE_MSG(TRACE_NWK1, ">> expiry_rreq p %hd", (FMT__H, param));

  TRACE_MSG(TRACE_NWK1, "rreq cnt %d", (FMT__D, ZG->nwk.nib.rreq_cnt));
  if ( ZG->nwk.nib.rreq_cnt )
  {
    zb_ushort_t i = 0;

    for (i = ZG->nwk.nib.rreq_num; i < ZB_NWK_RREQ_TABLE_SIZE; i++)
    {
      if ( ZG->nwk.nib.rreq[i].used )
      {
        /* check we have buffer to send */
        if ( param == (zb_uint8_t)(-1) )
        {
          /* wait for buffer */
          TRACE_MSG(TRACE_NWK1, "wait f/out buf", (FMT__0));
          ZB_GET_OUT_BUF_DELAYED(zb_nwk_mesh_expiry_rreq);
          goto done;
        }

        TRACE_MSG(TRACE_NWK1, "resend %d request", (FMT__D, i));
        zb_nwk_mesh_resend_rreq(ZB_BUF_FROM_REF(param), &ZG->nwk.nib.rreq[i]);
        param = -1;
      }
    }
    ZG->nwk.nib.rreq_num = 0;

    if ( ZG->nwk.nib.rreq_cnt )
    {
      /* Schedule to call later */
      ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_rreq, -1, ZB_NWK_RREQ_RETRY_INTERVAL);
    }
  }
  else
  {
    /* No route requests, do not schedule callback */
  }

  done:
  TRACE_MSG(TRACE_NWK1, "<< expiry_rreq", (FMT__0));
}
#endif


void nwk_route_disc_failed(zb_uint8_t param) ZB_CALLBACK
{
  zb_nlme_status_indication_t *status =  ZB_GET_BUF_PARAM(ZB_BUF_FROM_REF(param), zb_nlme_status_indication_t);

  TRACE_MSG(TRACE_NWK1, ">> nwk_route_disc_failed", (FMT__0));

  status->status = ZB_NWK_COMMAND_STATUS_NO_ROUTE_AVAILABLE;
  status->network_addr = ZG->nwk.handle.status_ind_addr;

  /* notify */
  ZB_SCHEDULE_CALLBACK(zb_nlme_status_indication, param);
  ZB_SCHEDULE_ALARM_CANCEL(zb_nwk_mesh_expiry_route_disc, 0);
  ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_route_disc, 0, ZB_NWK_EXPIRY_ROUTE_DISCOVERY);

  TRACE_MSG(TRACE_NWK1, ">> nwk_route_disc_failed", (FMT__0));
}

/* This function called periodically to find expired discovery table entries */
void zb_nwk_mesh_expiry_route_disc(zb_uint8_t param) ZB_CALLBACK
{
  ZVUNUSED(param);
  TRACE_MSG(TRACE_NWK1, ">> exp_r_disc", (FMT__0));

  if ( ZG->nwk.nib.route_disc_table_cnt )
  {
    zb_ushort_t i;

    TRACE_MSG(TRACE_NWK1, "disc tbl ent cnt %d", (FMT__D, ZG->nwk.nib.route_disc_table_cnt));
    for (i = 0; i < ZB_NWK_ROUTE_DISCOVERY_TABLE_SIZE; i++)
    {
      if ( ZG->nwk.nib.route_disc_table[i].used )
      {
        TRACE_MSG(TRACE_NWK1, "ent %d exp_time  %d", (FMT__D_D, i, ZG->nwk.nib.route_disc_table[i].expiration_time));
        if ( ZG->nwk.nib.route_disc_table[i].expiration_time )
        {
          ZG->nwk.nib.route_disc_table[i].expiration_time--;
        }
        else
        {
          zb_nwk_routing_t *route_ent;

          /* free corresponding route record if it's state is not active */
          NWK_ARRAY_FIND_ENT(ZG->nwk.nib.routing_table, route_ent,
                             (route_ent->dest_addr == ZG->nwk.nib.route_disc_table[i].dest_addr)
                             && (route_ent->status != ZB_NWK_ROUTE_STATE_ACTIVE) );

          /* free expired route discovery entry */
          TRACE_MSG(TRACE_NWK1, "free disc ent %d dst_addr %d", (FMT__D_D, i, ZG->nwk.nib.route_disc_table[i].dest_addr));
          NWK_ARRAY_PUT_ENT(ZG->nwk.nib.route_disc_table, &ZG->nwk.nib.route_disc_table[i], ZG->nwk.nib.route_disc_table_cnt);

          if ( route_ent )
          {
            /* report nwk status to the higher layers */
            ZG->nwk.handle.status_ind_addr = route_ent->dest_addr;
            ZB_GET_OUT_BUF_DELAYED(nwk_route_disc_failed);

            TRACE_MSG(TRACE_NWK1, "free routing entrie, addr %d", (FMT__D, route_ent->dest_addr));
            NWK_ARRAY_PUT_ENT(ZG->nwk.nib.routing_table, route_ent, ZG->nwk.nib.routing_table_cnt);
            goto done;
          }
        }
      }
    }
  }

  /* Schedule to call later */
  ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_route_disc, 0, ZB_NWK_EXPIRY_ROUTE_DISCOVERY);

  done:
  TRACE_MSG(TRACE_NWK1, "<< exp_r_disc", (FMT__0));
}

/* This function called periodically to find expired pending elements */
void zb_nwk_mesh_expiry_pending(zb_uint8_t param) ZB_CALLBACK
{
  ZVUNUSED(param);
  TRACE_MSG(TRACE_NWK1, ">> exp_pend", (FMT__0));

  if ( ZG->nwk.nib.pending_table_cnt )
  {
    zb_ushort_t i;

    for (i = 0; i < ZB_NWK_PENDING_TABLE_SIZE; i++)
    {
      if ( ZG->nwk.nib.pending_table[i].used )
      {
        TRACE_MSG(TRACE_NWK1, "pend ent %d dst_addr %d exp %d", (FMT__D_D_D,
                  i, ZG->nwk.nib.pending_table[i].dest_addr, ZG->nwk.nib.pending_table[i].expiry));
        if ( ZG->nwk.nib.pending_table[i].expiry == 0 )
        {
          TRACE_MSG(TRACE_NWK1, "free buf %p", (FMT__P, ZG->nwk.nib.pending_table[i].buf));
          zb_free_buf(ZG->nwk.nib.pending_table[i].buf);
          NWK_ARRAY_PUT_ENT(ZG->nwk.nib.pending_table, &ZG->nwk.nib.pending_table[i], ZG->nwk.nib.pending_table_cnt);
        }
        else
        {
          ZG->nwk.nib.pending_table[i].expiry--;
        }
      }
    }
  }

  /* Schedule to call later */
  ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_pending, 0, ZB_NWK_EXPIRY_PENDING);

  TRACE_MSG(TRACE_NWK1, "<< exp_pend", (FMT__0));
}

zb_nwk_routing_t *zb_nwk_mesh_find_route(zb_uint16_t dest_addr) ZB_SDCC_REENTRANT
{
  zb_nwk_routing_t *route;
  NWK_ARRAY_FIND_ENT(ZG->nwk.nib.routing_table, route, route->dest_addr == dest_addr);
  return route;
}

zb_nwk_route_discovery_t *zb_nwk_mesh_find_route_discovery_entry(zb_uint16_t dest_addr) ZB_SDCC_REENTRANT
{
  zb_nwk_route_discovery_t *disc_ent;
  NWK_ARRAY_FIND_ENT(ZG->nwk.nib.route_disc_table, disc_ent, disc_ent->dest_addr == dest_addr);
  return disc_ent;
}

zb_ret_t zb_nwk_mesh_add_buf_to_pending(zb_buf_t *buf, zb_uint8_t handle) ZB_SDCC_REENTRANT
{
  zb_ret_t ret = RET_OK;
  zb_nwk_hdr_t *nwhdr = (zb_nwk_hdr_t *)ZB_BUF_BEGIN(buf);
  zb_nwk_pend_t *pend;

  NWK_ARRAY_GET_ENT(ZG->nwk.nib.pending_table, pend, ZG->nwk.nib.pending_table_cnt);
  if ( pend )
  {
    TRACE_MSG(TRACE_ERROR, "buf %p added to pendlist", (FMT__P, buf));
    pend->buf       = buf;
    pend->handle    = handle;
    pend->dest_addr = nwhdr->dst_addr;
    pend->expiry    = ZB_NWK_PENDING_ENTRY_EXPIRY;
    pend->waiting_buf = 1;
  }
  else
  {
    ret = RET_NO_MEMORY;
  }

  return ret;
}

void zb_nwk_mesh_routing_deinit() ZB_SDCC_REENTRANT
{
  TRACE_MSG(TRACE_NWK1, ">> r_deinit", (FMT__0));

  ZB_SCHEDULE_ALARM_CANCEL(zb_nwk_mesh_expiry_pending, ZB_ALARM_ANY_PARAM);
  ZB_SCHEDULE_ALARM_CANCEL(zb_nwk_mesh_expiry_route_disc, ZB_ALARM_ANY_PARAM);
#if 0
  ZB_SCHEDULE_ALARM_CANCEL(zb_nwk_mesh_expiry_rreq, ZB_ALARM_ANY_PARAM);
#endif

  TRACE_MSG(TRACE_NWK1, "<< r_deinit", (FMT__0));
}

/*! @} */

#endif /* ZB_NWK_MESH_ROUTING && ZB_ROUTER_ROLE */
